# 인덱스!

> 데이터를 빠르게 찾을 수 있게 하는 역할을 한다.

- 인덱스 확인 

```mysql
SHOW INDEX FROM [테이블_이름]
```



- 인덱스 장점
  - 검색 속도가 빨라진다.(단, 아닌 경우도 있다.)
  - 해당 쿼리의 부하가 줄어서 시스템 전체 성능이 향상된다. 



- 인덱스 단점
  - 인덱스가 db공간을 차지해서 추가적인 공간이 필요해지는데 약 db의 10%정도의 추가 공간이 필요하다.
  - 처음 인덱스를 만드는데 시간이 오래 걸린다.
  - 데이터의 변경 작업이 자주 일어날 경우에는 성능이 나빠질 수 있다.
  - 페이지 분할로 인해 INSERT성능이 매우 나빠질 수 있다.



## 인덱스 종류

> MySQL에서는 보조 인덱스, 클러스터형 인덱스 2개 있다.



### 클러스터형 인덱스

> 테이블당 한 개만 생성 가능 (PRIMARY KEY)
>
> 행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬한다.



### 보조 인덱스

> 테이블당 여러 개 생성 가능 ( UNIQUE)



## 인덱스 자동 생성

✔️ `PRIMARY KEY`로 지정한 열은 **클러스터 형 인덱스**가 생성된다.

✔️`UNIQUE NOT NULL`로 지정한 열은 **클러스터 형 인덱스**가 생성된다.

✔️`UNIQUE (NULL) `로 지정한 열은 **보조 인덱스**가 생성된다.

✔️`PRIMARY KEY`와 `UNIQUE NOT NULL` 이 있으면 `PRIMARY KEY`로 지정한 열이 우선 **클러스터 형 인덱스**가 된다.
	(여기서 `UNIQUE NOT NULL`로 지정한 열은 **보조 인덱스 역할**을 한다.)

✔️PRIMARY KEY로 지정한 열로 데이터가 오름차순 정렬된다.





- 실습

```mysql
-- 기본키 기준으로 데이터 정렬 실습

CREATE DATABASE IF NOT EXISTS testdb;
USE testdb;
DROP TABLE IF EXISTS usertbl;
CREATE TABLE usertbl (
	userID char(8) NOT NULL PRIMARY Key,
    name varchar(10) not null,
    birthYear int not null,
    addr nchar(2) not null);

INSERT INTO usertbl VALUES('LSG','이승기',1987,'서울');
INSERT INTO usertbl VALUES('KBS','김범수',1979,'경남');
INSERT INTO usertbl VALUES('KKH','김경호',1971,'전남');
INSERT INTO usertbl VALUES('JYP','조용필',1950,'경기');
INSERT INTO usertbl VALUES('SSK','성시경',1979,'서울');
SELECT * FROM usertbl;

```

데이터가 입력되는 순서와 상관없이 기본키로 지정한 열의 데이터를 기준으로 오름차순 정렬하여 데이터가 저장된다.

![image-20230306154952707](%EC%9D%B8%EB%8D%B1%EC%8A%A4!.assets/image-20230306154952707.png)



---

```mysql
-- PRIMARY KEY가 클러스터 형 우선 순위다
create table tbl1 (
	a int PRIMARY KEY, 		-- 클러스터형 인덱스
    b int UNIQUE,			-- 보조 인덱스 역할
    c int UNIQUE not null, 	-- 보조 인덱스 역할
    d int );
show index from tbl1;
```

![image-20230306155820169](%EC%9D%B8%EB%8D%B1%EC%8A%A4!.assets/image-20230306155820169.png)