# 함수 모음

> MySQL에서 문자와 숫자를 비교할 때 문자를 숫자형으로 암시적 형 변환을 할 수 있는 문자라면 정수형으로 변환하여 비교하는데 정수형으로 변환이 안되는 문자라면 0으로 변환시켜 비교한다.
>
> 예를 들면 
>
> 'ASD' > 100 을 비교할 때 ASD는 숫자로 변환이 안되기 때문에 0(FALSE)이다.
>
> '123' > 100 을 비교하면 1(TRUE)이다.

## 데이터 형 변환 함수

### CAST()

```mysql
-- 정수로 형 변환
SELECT CAST(AVG(amount) AS SIGNED INTEGER) AS '평균 구매 개수' FROM buytbl;
-- 날짜 형으로 변환
SELECT CAST('2023&02&16' AS DATE) AS '오늘 날짜';
```



### CONVERT()

```mysql
SELECT CONVERT(AVG(amount), SIGNED INTEGER) AS '평균 구매 개수' FROM buytbl;
```

CAST함수와 CONVERT함수는 문법에 약간의 차이가 있다.

AS 와 콤마 차이다.



## 제어 흐름 함수



### IF(수식, 참, 거짓)

> 수식이 참이면 참, 아니면 거짓을 반환한다.

```mysql
SELECT IF (1 > 10, '참', '거짓'); -- 결과는 거짓 일것이다.
```



### IFNULL(수식1, 수식2)

> 수식 1이 NULL이면 수식2를 반환하고, 아니면 수식1이 그대로 반환된다.

```mysql
SELECT IFNULL(NULL,'널이다.');					-- 널이다.
SELECT IFNULL('널이 아님','수식1이 반환된다.');	-- 널이 아님
```



### NULLIF(수식1, 수식2)

수식1과 2가 같으면 NULL을 반환하고 아니면 수식1을 반환한다.

```mysql
SELECT NULLIF(1,1); -- NULL
SELECT NULLIF(1,0); -- 1
SELECT NULLIF('Hi','A'); -- Hi
SELECT NULLIF('Hi',0);	-- NULL 이경우는 서로 다른데 문자와 숫자를 비교할때 문자를 0으로 봐서 NULL이 나온듯 하다.
```



### CASE ~ WHEN ~ ELSE ~ END

> CASE는 내장 함수가 아닌 연산자이다.

```mysql
SELECT CASE 11 -- CASE뒤에 오는 숫자로 비교하는데 이경우 11을 입력해서 뭐죠?가 반환된다.
	WHEN 1 THEN '하나'
    WHEN 5 THEN '다섯'
    WHEN 10 THEN '열'
    ELSE '뭐죠?'
END AS 'CASE실습';
```

이거 컴활 1급 실기에서 많이 사용했던 CASE문과 비슷해서 참 친숙하다.

역시 뭐든 배워두면 통하는구나



## 문자열 함수



### 아스키 코드

```mysql
SELECT ASCII('A'), CHAR(65); -- 65, A
```



### BIT_LENGTH(문자열)

> 문자열의 Bit 크기를 반환

```mysql
SELECT BIT_LENGTH('abs'); -- 각 1바이트는 8비트로 3개니까 3바이트 -> 8*3 = 24
SELECT BIT_LENGTH('가나다'); -- 한글은 각 3바이트라서 24비트임 24비트가 3개라서 72BIT
```



### CHAR_LENGTH(문자열)

> 문자열의 길이를 반환

```mysql
SELECT CHAR_LENGTH('AVS'); -- 단순 개수 출력 3
SELECT CHAR_LENGTH('가나다');
```



### LENGTH(문자열)

> 문자열의 Byte 반환

```mysql
SELECT LENGTH('AVS'); -- 바이트 수를 반환한다. 영어는 각 1바이트 3개라서 3
SELECT LENGTH('가나다'); -- 한글은 각 3바이트 3개니까 9
```



### CONCAT(문자열1, 문자열2,...)

> 문자열을 이어준다.

```mysql
SELECT CONCAT('내 생일은','4월','21일','이다') AS '생일';
--'내 생일은4월21일이다'
```



### CONCAT_WS(구분자, 문자열1, 문자열2,.....)

> 구분자와 함께 문자열을 이어준다.

```mysql
SELECT CONCAT_WS('-','010','3230','0000');
-- '010-3230-0000'

SELECT CONCAT('번호:',CONCAT_WS('-','010','3230','0000')) AS '전화번호';
-- '번호:010-3230-0000'

```



### ELT(위치, 문자열1, 문자열2,....)

> 위치 번째에 해당하는 문자열을 반환

```mysql
SELECT ELT(2,'A','B','C'); -- B 반환
```





### FIELD(찾을 문자열, 문자열1, 문자열2,...)

> 찾을 문자열의 위치 반환, 매치되는 문자열이 없으면 0 반환

```mysql
SELECT FIELD('LOL','HELLO','THERE','LOL'); -- 3
SELECT FIELD('L','HELLO','THERE','LOL');   -- 0
```



### FIND_IN_SET(찾을 문자열, 문자열 리스트)

> 찾을 문자열 위치를 반환

```mysql
SELECT find_in_set('CAT','LOL,CAT,MONEY'); -- 2
```

문자열을 따옴표에 한번에 담는게 인상적임. 콤마로 구분함

### INSTR(기준 문자열, 부분 문자열)

> 기준 문자열에서 부분 문자열을 찾아 시작 위치를 반환

```mysql
SELECT instr('HELLO','L'); -- 3
SELECT instr('HELLO','EL'); -- 2
SELECT instr('HELLO','ELA'); -- 0
```

왼쪽부터 가장 처음에 나오는 값을 반환 하나보다.

### LOCATE(부분 문자열, 기준 문자열)

> 기준 문자열에서 부분 문자열을 찾아 시작 위치를 반환



```mysql
SELECT LOCATE('RL','WORLD'); -- 3
SELECT LOCATE('RLA','WORLD'); -- 0
```



### FORMAT(숫자, 소수점 자릿수)

> 숫자를 소수점 아래 자릿수까지 표현
>
> 1000 단위로 , 구분

```mysql
SELECT format(3000.123,2); -- 3,000.12
```



### BIN, HEX, OCT(숫자)

> 2진수, 16진수, 8진수 값 반환



### INSERT(기준문자열, 위치, 길이, 삽입할 문자열)

> 기준 문자열의 위치 번째부터 길이만큼 지우고 삽입 문자를 삽입한다.

 ```mysql
 SELECT INSERT('helllll',5,4,'o'); -- hell 길이를 초과해서 입력해도 오류는 안났다.
 SELECT INSERT('helllll',5,1,'o'); -- helloll
 ```



### LEFT(문자열, 길이), RIGHT(문자열,길이)

> 왼쪽 길이만큼 반환, 오른쪽 길이만큼 반환 (파이썬으로 치면 슬라이싱 같다.)

```mysql
SELECT CONCAT(LEFT('Hi, ㅎㅎ',3), RIGHT('RIGHT There',5));
-- Hi,There
```



### UPPER(문자열), LOWER(문자열)

> 대문자 , 소문자 파이썬이랑 똑같음



### LPAD(문자열, 길이, 채울 문자열)

```mysql
SELECT LPAD('나는 누구지',10,'?');
-- '????나는 누구지'
```



###  RPAD(문자열, 길이, 채울 문자열)

```mysql
SELECT RPAD('나는 누구지',10,'?');
-- '나는 누구지????'
```



### TRIM(문자열), LTRIM(문자열), RTRIM(문자열)

> 문자열의 양쪽 / 왼쪽/ 오른쪽 공백 제거
>
> 파이썬이랑 똑같음



### TRIM( LEADING(앞) / BOTH(양쪽) / TRAILING(뒤) FROM 문자열)

```mysql
SELECT TRIM(BOTH '?' FROM '???나는??누구지???'); -- 나는??누구지 가운데는 안지워짐
SELECT TRIM(LEADING '?' FROM '???나는??누구지???'); -- 나는??누구지???
SELECT TRIM(TRAILING '?' FROM '???나는??누구지???'); -- ???나는??누구지
```



### REPEAT(문자, 반복 수)

> 문자를 반복 수 만큼 반복한다.

```mysql
SELECT repeat('Ha',3); -- HaHaHa
```



### REPLACE(문자열, 어떤 문자, 새 문자)

> 문자열에 있는 어떤 문자를 새 문자로 바꾼다.

```mysql
SELECT replace('실습이 오래걸리네','오래걸리네','재미나네');
-- 실습이 재미나네
```



### REVERSE(문자열)

> 문자열을 뒤집어 출력



### SPACE(길이)

> 길이만큼 공백이 추가된다.

```mysql
SELECT CONCAT('이거',SPACE(3),'오래걸리네');
-- 이거   오래걸리네
```



### SUBSTRING(문자열, 시작위치, 길이) , SUBSTRING(문자열 FROM 시작위치 FOR 길이) 

> 시작 위치부터 길이 만큼 문자를 반환, 길이가 생략되면 문자열의 끝까지 반환

```mysql
SELECT substring('DRF도 해야하는데',1,3); -- DRF
SELECT substring('DRF도 해야하는데',6); -- 해야하는데
```



### SUBSTRING_INDEX(문자열, 구분자, 횟수)

```mysql
SELECT SUBSTRING_INDEX('www.naver.com','a',2); -- 'www.naver.com'
-- 왼쪽에서 a를 두번 찾아야하는데 없어서 전체 출력
SELECT SUBSTRING_INDEX('www.naver.com','w',2); -- w
-- 왼쪽에서 w을 찾다가 2번째 전에 있는 문자 반환
SELECT SUBSTRING_INDEX('www.naver.com','w',-2); -- 'w.naver.com'
-- 오른쪽에서 w를 찾다가 2번쩨 전에있는 문자 반환 (이제까지 지나온 애들 출력한다는 거임)
SELECT SUBSTRING_INDEX('www.naver.com','.',2); -- 'www.naver'
SELECT SUBSTRING_INDEX('www.naver.com','.',-2); -- 'naver.com'
```

