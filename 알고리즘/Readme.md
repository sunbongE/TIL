# 알고리즘



## 재귀함수

> 코드 내에서 자기 자신을 호출하는 것을 의미한다.
>
> 왜 사용하는가? 
>
> 재귀를 사용하지 않고 for, while 문으로 작성하는 것은 
>
> 가독성이 떨어지기 때문에 재귀 함수를 사용하는 것이 개발자가 유지보수하기에 유리하다. 

```python
# 재귀함수 형태
def dfs(N):  				#2. 0을 받아옴
    print('재귀')			   #3. 재귀라는 문자가 나옴
    return dfs(N+1)			#4. 자신을 호출! 이게 재귀 함수

# main
ans = dfs(0) 				#1. 함수호출
print(ans)
```

이렇게 영원히 반복하는 함수가 돼서 컴퓨터 메모리가 허락하는 한 출력할 것이다.

그래서 재귀 함수는 if문을 통해 재귀 함수 종료 조건이 있어야 한다. 그 것을 **Base Condition** 이라고 부르고

재귀 함수는 매개변수를 통해 **Base Condition** 에 점점 가까워지게 설계한다.

 우리는 이런 형태를 가지고 dfs(깊이 우선 탐색)을 할 것이다.

```python
# 재귀함수 형태
def dfs(N):  				#2. 0을 받아옴
    if N == 5:				# 0,1,2,3,4 이후  if문이 참
    	return				# 참이면 리턴
    
    print('재귀')			   #3. 재귀라는 문자가 나옴
    return dfs(N+1)			#4. 자신을 호출! 이게 재귀 함수

# main
ans = dfs(0) 				#1. 함수호출
print(ans)
```



 

**역순 정렬	**

모든 함수는 return으로 종료된다. 

기존에 생성된 함수는  호출된 역순으로 끝나는데

스택 구조 개념으로 생각하면 된다.

```python
# 재귀함수 역순 형태
def dfs(N):  				#2. 0을 받아옴
    if N == 5:				# 0,1,2,3,4 이후  if문이 참
    	return				# 참이면 리턴 
    dfs(N+1)				#3. 바로 함수 호출 
    print('N')			   #4. 4,3,2,1,0 출력
    return 			 

# main
ans = dfs(0) 				#1. 함수호출
print(ans)
```





## DFS

어떤 문제를 끝까지 탐색해야 답이 나오는 경우(완전 탐색, 브루트 포스) 사용된다.

dfs을 수행하는 중간에 답일 가능성이 없는 것은 탐색하지 않게 만드는 것을 가지치기 라고 하는데

이를 백트래킹(수행 시간을 많이 줄일 수 있음) 이라고 한다.

예시)

1~5까지 오름차순으로 중복 없이 3개를 뽑아야 한다면



```python
# dfs
1,1,1
1,1,2
1,1,3
1,1,4
1,1,5
# 이런식으로 전부 탐색
-------
1,2,3
1,2,4
1,2,5
1,3,4	# 1,3,2 이런 불필요한 답이 될 수 없는 경우를 탐색하는 행위를 하지 않는 것
.		# 그런 역할을 하게 하는 것이 백트래킹이다.
.
#이래서 시간이 단축이 가능하구나..

```

 