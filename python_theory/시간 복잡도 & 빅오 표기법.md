# 시간 복잡도 & 빅오 표기법

> 가장 좋은 것은 상수 복잡도다.
>
> 실제 코드에서 보통은 O(N^2)에서 해결하는 것이 좋다고 한다.

## 시간 복잡도(알고리즘 수행시간)

시간 복잡도가 높다 = 느린 알고리즘

시간 복잡도가 낮다 = 빠른 알고리즘



**측정법**

1. 기본연산이 몇번인지 (기본연산의 총 횟수 == 알고리즘의 소요 시간)
2. 성능을 측정할 때 입력을 통일시킴, (입력n에 따른)







##  빅오(Big-O) 표기법

입력 n이 무한대로 커진다고 가정하고 시간복잡도를 간단히 표시한 것

최고차항만 남기고 계수와 상수 제거하여 나타낸다.

증가율에 초점을 맞춰야한다.



![bigO](%EC%8B%9C%EA%B0%84%20%EB%B3%B5%EC%9E%A1%EB%8F%84%20&%20%EB%B9%85%EC%98%A4%20%ED%91%9C%EA%B8%B0%EB%B2%95.assets/bigO.jpeg)



**(가우스의 합 공식) = (n*(n+1)) // 2**

| 표기     | 내용                                 |
| -------- | ------------------------------------ |
| O(1)     | 단순 산술 계산(+, -, *, /)           |
| O(logN)  | 크기 N인 리스트를 반절씩 순회/탐색   |
| O(N)     | 크기 N인 리스트를 순회               |
| O(NlogN) | 크기 N인 리스트를 반절씩 탐색 * 순회 |
| O(N^2)   | 크기 M, N인 2중 리스트를 순회        |
| O(N^3)   | 3중 리스트 순회                      |
| O(2^N)   | 크기 N 집합의 부분 집합              |
| O(N!)    | 크기  N 리스트의 순열                |

```python
# 1 부터 10까지 더하기
nums = 10
sum_ = 0
for num in range(1,nums+1):
    sum_ += num
print(sum_) # 55
# 위 코드는 O(N)이다 한번 순회하기 때문이다.
# 이런 코드를 더 간결하게 상수 복잡도로 나타내는 것이
# 속도에 있어서 바람직하다. 가능하다면 수식으로 나타내는것이 좋다는 것
# 가우디의 합 공식
sum2 = nums*(nums+1)//2
print(sum2) # 55
# 같은 결과지만 시간복잡도의 차이는 엄청나다.
```

